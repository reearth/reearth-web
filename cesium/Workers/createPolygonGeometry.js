define(["./when-4bbc8319","./Matrix2-c6c16658","./ArcType-fc72c06c","./GeometryOffsetAttribute-821af768","./BoundingRectangle-a97789b6","./Transforms-f15de320","./RuntimeError-5b082e8f","./ComponentDatatype-3d0a0aac","./EllipsoidGeodesic-2e7ba57d","./EllipsoidTangentPlane-41514392","./GeometryAttribute-8350368e","./GeometryInstance-0b07c761","./GeometryPipeline-0fb7cb2c","./IndexDatatype-ddbc25a7","./PolygonGeometryLibrary-a02d6b0b","./PolygonPipeline-ff4d4077","./VertexFormat-7b982b01","./combine-e9466e32","./WebGLConstants-508b9636","./AxisAlignedBoundingBox-a572809f","./IntersectionTests-a4e54d9a","./Plane-26e67b94","./AttributeCompression-f7a901f9","./EncodedCartesian3-b1495e46","./arrayRemoveDuplicates-80a91d16","./EllipsoidRhumbLine-c6741351","./GeometryAttributes-7827a6c2"],(function(t,e,o,i,n,r,a,s,l,c,u,p,m,y,g,d,h,f,b,_,P,x,w,C,T,I,A){"use strict";const E=new e.Cartographic,v=new e.Cartographic;function G(t,e,o,i){const n=i.cartesianToCartographic(t,E).height,r=i.cartesianToCartographic(e,v);r.height=n,i.cartographicToCartesian(r,e);const a=i.cartesianToCartographic(o,v);a.height=n-100,i.cartographicToCartesian(a,o)}const O=new n.BoundingRectangle,V=new e.Cartesian3,F=new e.Cartesian3,D=new e.Cartesian3,L=new e.Cartesian3,N=new e.Cartesian3,H=new e.Cartesian3;let R=new e.Cartesian3,M=new e.Cartesian3,S=new e.Cartesian3;const B=new e.Cartesian2,k=new e.Cartesian2,z=new e.Cartesian3,W=new r.Quaternion,Y=new e.Matrix3,U=new e.Matrix3;function j(o){const n=o.vertexFormat,a=o.geometry,l=o.shadowVolume,c=a.attributes.position.values;let p=c.length;const m=o.wall,y=o.top||m,g=o.bottom||m;if(n.st||n.normal||n.tangent||n.bitangent||l){const t=o.boundingRectangle,i=o.tangentPlane,d=o.ellipsoid,h=o.stRotation,f=o.perPositionHeight,b=B;b.x=t.x,b.y=t.y;const _=n.st?new Float32Array(p/3*2):void 0;let P;n.normal&&(P=f&&y&&!m?a.attributes.normal.values:new Float32Array(p));const x=n.tangent?new Float32Array(p):void 0,w=n.bitangent?new Float32Array(p):void 0,C=l?new Float32Array(p):void 0;let T=0,I=0,A=F,E=D,v=L,O=!0,j=Y,Q=U;if(0!==h){let t=r.Quaternion.fromAxisAngle(i._plane.normal,h,W);j=e.Matrix3.fromQuaternion(t,j),t=r.Quaternion.fromAxisAngle(i._plane.normal,-h,W),Q=e.Matrix3.fromQuaternion(t,Q)}else j=e.Matrix3.clone(e.Matrix3.IDENTITY,j),Q=e.Matrix3.clone(e.Matrix3.IDENTITY,Q);let q=0,K=0;y&&g&&(q=p/2,K=p/3,p/=2);for(let r=0;r<p;r+=3){const a=e.Cartesian3.fromArray(c,r,z);if(n.st){let o=e.Matrix3.multiplyByVector(j,a,V);o=d.scaleToGeodeticSurface(o,o);const n=i.projectPointOntoPlane(o,k);e.Cartesian2.subtract(n,b,n);const r=s.CesiumMath.clamp(n.x/t.width,0,1),l=s.CesiumMath.clamp(n.y/t.height,0,1);g&&(_[T+K]=r,_[T+1+K]=l),y&&(_[T]=r,_[T+1]=l),T+=2}if(n.normal||n.tangent||n.bitangent||l){const t=I+1,i=I+2;if(m){if(r+3<p){const t=e.Cartesian3.fromArray(c,r+3,N);if(O){const o=e.Cartesian3.fromArray(c,r+p,H);f&&G(a,t,o,d),e.Cartesian3.subtract(t,a,t),e.Cartesian3.subtract(o,a,o),A=e.Cartesian3.normalize(e.Cartesian3.cross(o,t,A),A),O=!1}e.Cartesian3.equalsEpsilon(t,a,s.CesiumMath.EPSILON10)&&(O=!0)}(n.tangent||n.bitangent)&&(v=d.geodeticSurfaceNormal(a,v),n.tangent&&(E=e.Cartesian3.normalize(e.Cartesian3.cross(v,A,E),E)))}else A=d.geodeticSurfaceNormal(a,A),(n.tangent||n.bitangent)&&(f&&(R=e.Cartesian3.fromArray(P,I,R),M=e.Cartesian3.cross(e.Cartesian3.UNIT_Z,R,M),M=e.Cartesian3.normalize(e.Matrix3.multiplyByVector(Q,M,M),M),n.bitangent&&(S=e.Cartesian3.normalize(e.Cartesian3.cross(R,M,S),S))),E=e.Cartesian3.cross(e.Cartesian3.UNIT_Z,A,E),E=e.Cartesian3.normalize(e.Matrix3.multiplyByVector(Q,E,E),E),n.bitangent&&(v=e.Cartesian3.normalize(e.Cartesian3.cross(A,E,v),v)));n.normal&&(o.wall?(P[I+q]=A.x,P[t+q]=A.y,P[i+q]=A.z):g&&(P[I+q]=-A.x,P[t+q]=-A.y,P[i+q]=-A.z),(y&&!f||m)&&(P[I]=A.x,P[t]=A.y,P[i]=A.z)),l&&(m&&(A=d.geodeticSurfaceNormal(a,A)),C[I+q]=-A.x,C[t+q]=-A.y,C[i+q]=-A.z),n.tangent&&(o.wall?(x[I+q]=E.x,x[t+q]=E.y,x[i+q]=E.z):g&&(x[I+q]=-E.x,x[t+q]=-E.y,x[i+q]=-E.z),y&&(f?(x[I]=M.x,x[t]=M.y,x[i]=M.z):(x[I]=E.x,x[t]=E.y,x[i]=E.z))),n.bitangent&&(g&&(w[I+q]=v.x,w[t+q]=v.y,w[i+q]=v.z),y&&(f?(w[I]=S.x,w[t]=S.y,w[i]=S.z):(w[I]=v.x,w[t]=v.y,w[i]=v.z))),I+=3}}n.st&&(a.attributes.st=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:_})),n.normal&&(a.attributes.normal=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:P})),n.tangent&&(a.attributes.tangent=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:x})),n.bitangent&&(a.attributes.bitangent=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:w})),l&&(a.attributes.extrudeDirection=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C}))}if(o.extrude&&t.defined(o.offsetAttribute)){const t=c.length/3;let e=new Uint8Array(t);if(o.offsetAttribute===i.GeometryOffsetAttribute.TOP)y&&g||m?e=i.arrayFill(e,1,0,t/2):y&&(e=i.arrayFill(e,1));else{const t=o.offsetAttribute===i.GeometryOffsetAttribute.NONE?0:1;e=i.arrayFill(e,t)}a.attributes.applyOffset=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}return a}const Q=new e.Cartographic,q=new e.Cartographic,K={westOverIDL:0,eastOverIDL:0};let Z=new l.EllipsoidGeodesic;function J(i,n,r,a,c){if(c=t.defaultValue(c,new e.Rectangle),!t.defined(i)||i.length<3)return c.west=0,c.north=0,c.south=0,c.east=0,c;if(r===o.ArcType.RHUMB)return e.Rectangle.fromCartesianArray(i,n,c);Z.ellipsoid.equals(n)||(Z=new l.EllipsoidGeodesic(void 0,void 0,n)),c.west=Number.POSITIVE_INFINITY,c.east=Number.NEGATIVE_INFINITY,c.south=Number.POSITIVE_INFINITY,c.north=Number.NEGATIVE_INFINITY,K.westOverIDL=Number.POSITIVE_INFINITY,K.eastOverIDL=Number.NEGATIVE_INFINITY;const u=1/s.CesiumMath.chordLength(a,n.maximumRadius),p=i.length;let m,y=n.cartesianToCartographic(i[0],q),g=Q;for(let t=1;t<p;t++)m=g,g=y,y=n.cartesianToCartographic(i[t],m),Z.setEndPoints(g,y),$(Z,u,c,K);return m=g,g=y,y=n.cartesianToCartographic(i[0],m),Z.setEndPoints(g,y),$(Z,u,c,K),c.east-c.west>K.eastOverIDL-K.westOverIDL&&(c.west=K.westOverIDL,c.east=K.eastOverIDL,c.east>s.CesiumMath.PI&&(c.east=c.east-s.CesiumMath.TWO_PI),c.west>s.CesiumMath.PI&&(c.west=c.west-s.CesiumMath.TWO_PI)),c}const X=new e.Cartographic;function $(t,e,o,i){const n=t.surfaceDistance,r=Math.ceil(n*e),a=r>0?n/(r-1):Number.POSITIVE_INFINITY;let l=0;for(let e=0;e<r;e++){const e=t.interpolateUsingSurfaceDistance(l,X);l+=a;const n=e.longitude,r=e.latitude;o.west=Math.min(o.west,n),o.east=Math.max(o.east,n),o.south=Math.min(o.south,r),o.north=Math.max(o.north,r);const c=n>=0?n:n+s.CesiumMath.TWO_PI;i.westOverIDL=Math.min(i.westOverIDL,c),i.eastOverIDL=Math.max(i.eastOverIDL,c)}}const tt=[];function et(t,e,o,i,n,r,a,s,l){const u={walls:[]};let m;if(r||a){const i=g.PolygonGeometryLibrary.createGeometryFromPositions(t,e,o,n,s,l),c=i.attributes.position.values,d=i.indices;let h,f;if(r&&a){const t=c.concat(c);h=t.length/3,f=y.IndexDatatype.createTypedArray(h,2*d.length),f.set(d);const e=d.length,o=h/2;for(m=0;m<e;m+=3){const t=f[m]+o,i=f[m+1]+o,n=f[m+2]+o;f[m+e]=n,f[m+1+e]=i,f[m+2+e]=t}if(i.attributes.position.values=t,n&&s.normal){const e=i.attributes.normal.values;i.attributes.normal.values=new Float32Array(t.length),i.attributes.normal.values.set(e)}i.indices=f}else if(a){for(h=c.length/3,f=y.IndexDatatype.createTypedArray(h,d.length),m=0;m<d.length;m+=3)f[m]=d[m+2],f[m+1]=d[m+1],f[m+2]=d[m];i.indices=f}u.topAndBottom=new p.GeometryInstance({geometry:i})}let h=i.outerRing,f=c.EllipsoidTangentPlane.fromPoints(h,t),b=f.projectPointsOntoPlane(h,tt),_=d.PolygonPipeline.computeWindingOrder2D(b);_===d.WindingOrder.CLOCKWISE&&(h=h.slice().reverse());let P=g.PolygonGeometryLibrary.computeWallGeometry(h,t,o,n,l);u.walls.push(new p.GeometryInstance({geometry:P}));const x=i.holes;for(m=0;m<x.length;m++){let e=x[m];f=c.EllipsoidTangentPlane.fromPoints(e,t),b=f.projectPointsOntoPlane(e,tt),_=d.PolygonPipeline.computeWindingOrder2D(b),_===d.WindingOrder.COUNTER_CLOCKWISE&&(e=e.slice().reverse()),P=g.PolygonGeometryLibrary.computeWallGeometry(e,t,o,n,l),u.walls.push(new p.GeometryInstance({geometry:P}))}return u}function ot(i){const n=i.polygonHierarchy,r=t.defaultValue(i.vertexFormat,h.VertexFormat.DEFAULT),a=t.defaultValue(i.ellipsoid,e.Ellipsoid.WGS84),l=t.defaultValue(i.granularity,s.CesiumMath.RADIANS_PER_DEGREE),c=t.defaultValue(i.stRotation,0),u=t.defaultValue(i.perPositionHeight,!1),p=u&&t.defined(i.extrudedHeight);let m=t.defaultValue(i.height,0),y=t.defaultValue(i.extrudedHeight,m);if(!p){const t=Math.max(m,y);y=Math.min(m,y),m=t}this._vertexFormat=h.VertexFormat.clone(r),this._ellipsoid=e.Ellipsoid.clone(a),this._granularity=l,this._stRotation=c,this._height=m,this._extrudedHeight=y,this._closeTop=t.defaultValue(i.closeTop,!0),this._closeBottom=t.defaultValue(i.closeBottom,!0),this._polygonHierarchy=n,this._perPositionHeight=u,this._perPositionHeightExtrude=p,this._shadowVolume=t.defaultValue(i.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=i.offsetAttribute,this._arcType=t.defaultValue(i.arcType,o.ArcType.GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this.packedLength=g.PolygonGeometryLibrary.computeHierarchyPackedLength(n)+e.Ellipsoid.packedLength+h.VertexFormat.packedLength+12}ot.fromPositions=function(e){return new ot({polygonHierarchy:{positions:(e=t.defaultValue(e,t.defaultValue.EMPTY_OBJECT)).positions},height:e.height,extrudedHeight:e.extrudedHeight,vertexFormat:e.vertexFormat,stRotation:e.stRotation,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,closeTop:e.closeTop,closeBottom:e.closeBottom,offsetAttribute:e.offsetAttribute,arcType:e.arcType})},ot.pack=function(o,i,n){return n=t.defaultValue(n,0),n=g.PolygonGeometryLibrary.packPolygonHierarchy(o._polygonHierarchy,i,n),e.Ellipsoid.pack(o._ellipsoid,i,n),n+=e.Ellipsoid.packedLength,h.VertexFormat.pack(o._vertexFormat,i,n),n+=h.VertexFormat.packedLength,i[n++]=o._height,i[n++]=o._extrudedHeight,i[n++]=o._granularity,i[n++]=o._stRotation,i[n++]=o._perPositionHeightExtrude?1:0,i[n++]=o._perPositionHeight?1:0,i[n++]=o._closeTop?1:0,i[n++]=o._closeBottom?1:0,i[n++]=o._shadowVolume?1:0,i[n++]=t.defaultValue(o._offsetAttribute,-1),i[n++]=o._arcType,i[n]=o.packedLength,i};const it=e.Ellipsoid.clone(e.Ellipsoid.UNIT_SPHERE),nt=new h.VertexFormat,rt={polygonHierarchy:{}};return ot.unpack=function(o,i,n){i=t.defaultValue(i,0);const r=g.PolygonGeometryLibrary.unpackPolygonHierarchy(o,i);i=r.startingIndex,delete r.startingIndex;const a=e.Ellipsoid.unpack(o,i,it);i+=e.Ellipsoid.packedLength;const s=h.VertexFormat.unpack(o,i,nt);i+=h.VertexFormat.packedLength;const l=o[i++],c=o[i++],u=o[i++],p=o[i++],m=1===o[i++],y=1===o[i++],d=1===o[i++],f=1===o[i++],b=1===o[i++],_=o[i++],P=o[i++],x=o[i];return t.defined(n)||(n=new ot(rt)),n._polygonHierarchy=r,n._ellipsoid=e.Ellipsoid.clone(a,n._ellipsoid),n._vertexFormat=h.VertexFormat.clone(s,n._vertexFormat),n._height=l,n._extrudedHeight=c,n._granularity=u,n._stRotation=p,n._perPositionHeightExtrude=m,n._perPositionHeight=y,n._closeTop=d,n._closeBottom=f,n._shadowVolume=b,n._offsetAttribute=-1===_?void 0:_,n._arcType=P,n.packedLength=x,n},ot.computeRectangle=function(i,n){const r=t.defaultValue(i.granularity,s.CesiumMath.RADIANS_PER_DEGREE),a=t.defaultValue(i.arcType,o.ArcType.GEODESIC),l=i.polygonHierarchy,c=t.defaultValue(i.ellipsoid,e.Ellipsoid.WGS84);return J(l.positions,c,a,r,n)},ot.createGeometry=function(e){const o=e._vertexFormat,n=e._ellipsoid,a=e._granularity,l=e._stRotation,h=e._polygonHierarchy,f=e._perPositionHeight,b=e._closeTop,_=e._closeBottom,P=e._arcType;let x=h.positions;if(x.length<3)return;const w=c.EllipsoidTangentPlane.fromPoints(x,n),C=g.PolygonGeometryLibrary.polygonsFromHierarchy(h,w.projectPointsOntoPlane.bind(w),!f,n),T=C.hierarchy,I=C.polygons;if(0===T.length)return;x=T[0].outerRing;const A=g.PolygonGeometryLibrary.computeBoundingRectangle(w.plane.normal,w.projectPointOntoPlane.bind(w),x,l,O),E=[],v=e._height,G=e._extrudedHeight,V={perPositionHeight:f,vertexFormat:o,geometry:void 0,tangentPlane:w,boundingRectangle:A,ellipsoid:n,stRotation:l,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:P};let F;if(e._perPositionHeightExtrude||!s.CesiumMath.equalsEpsilon(v,G,0,s.CesiumMath.EPSILON2))for(V.extrude=!0,V.top=b,V.bottom=_,V.shadowVolume=e._shadowVolume,V.offsetAttribute=e._offsetAttribute,F=0;F<I.length;F++){const t=et(n,I[F],a,T[F],f,b,_,o,P);let e;b&&_?(e=t.topAndBottom,V.geometry=g.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(e.geometry,v,G,n,f)):b?(e=t.topAndBottom,e.geometry.attributes.position.values=d.PolygonPipeline.scaleToGeodeticHeight(e.geometry.attributes.position.values,v,n,!f),V.geometry=e.geometry):_&&(e=t.topAndBottom,e.geometry.attributes.position.values=d.PolygonPipeline.scaleToGeodeticHeight(e.geometry.attributes.position.values,G,n,!0),V.geometry=e.geometry),(b||_)&&(V.wall=!1,e.geometry=j(V),E.push(e));const i=t.walls;V.wall=!0;for(let t=0;t<i.length;t++){const e=i[t];V.geometry=g.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(e.geometry,v,G,n,f),e.geometry=j(V),E.push(e)}}else for(F=0;F<I.length;F++){const r=new p.GeometryInstance({geometry:g.PolygonGeometryLibrary.createGeometryFromPositions(n,I[F],a,f,o,P)});if(r.geometry.attributes.position.values=d.PolygonPipeline.scaleToGeodeticHeight(r.geometry.attributes.position.values,v,n,!f),V.geometry=r.geometry,r.geometry=j(V),t.defined(e._offsetAttribute)){const t=r.geometry.attributes.position.values.length,o=new Uint8Array(t/3),n=e._offsetAttribute===i.GeometryOffsetAttribute.NONE?0:1;i.arrayFill(o,n),r.geometry.attributes.applyOffset=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}E.push(r)}const D=m.GeometryPipeline.combineInstances(E)[0];D.attributes.position.values=new Float64Array(D.attributes.position.values),D.indices=y.IndexDatatype.createTypedArray(D.attributes.position.values.length/3,D.indices);const L=D.attributes,N=r.BoundingSphere.fromVertices(L.position.values);return o.position||delete L.position,new u.Geometry({attributes:L,indices:D.indices,primitiveType:D.primitiveType,boundingSphere:N,offsetAttribute:e._offsetAttribute})},ot.createShadowVolume=function(t,e,o){const i=t._granularity,n=t._ellipsoid,r=e(i,n),a=o(i,n);return new ot({polygonHierarchy:t._polygonHierarchy,ellipsoid:n,stRotation:t._stRotation,granularity:i,perPositionHeight:!1,extrudedHeight:r,height:a,vertexFormat:h.VertexFormat.POSITION_ONLY,shadowVolume:!0,arcType:t._arcType})},Object.defineProperties(ot.prototype,{rectangle:{get:function(){if(!t.defined(this._rectangle)){const t=this._polygonHierarchy.positions;this._rectangle=J(t,this._ellipsoid,this._arcType,this._granularity)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return t.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){const e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];const o=t._ellipsoid,i=t._polygonHierarchy.positions,n=t.rectangle;return u.Geometry._textureCoordinateRotationPoints(i,e,o,n)}(this)),this._textureCoordinateRotationPoints}}}),function(o,i){return t.defined(i)&&(o=ot.unpack(o,i)),o._ellipsoid=e.Ellipsoid.clone(o._ellipsoid),ot.createGeometry(o)}}));